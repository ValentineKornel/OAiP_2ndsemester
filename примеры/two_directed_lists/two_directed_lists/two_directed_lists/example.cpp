/*#include <iostream> // подключение библиотеки для стандартных операций ввода/вывода
using namespace std; // директива using, которая позволяет использовать пространство имен std без указания префикса std.

struct node // определение структуры элемента списка
{
    int elem; // информационное поле
    node* sled; // указатель на следующий элемент
    node* pred; // указатель на предыдущий элемент
};
class Spisok // класс для работы со списком
{
private:
    node* nsp, * ksp;  // указатели на начало и конец списка
public:
    Spisok() { nsp = ksp = NULL; } // конструктор класса, инициализирующий начало и конец списка
    void Postroenie(); // функция для построения списка
    void VyvodForward(); // функция для вывода списка в прямом направлении
    void VyvodBack(); // функция для вывода списка в обратном направлении
    void Ochistka(); // функция для очистки списка
    void InsAfter(int, node*);// функция для вставки нового элемента после заданного
    void InsBefore(int, node*); // функция для вставки нового элемента перед заданным
    void Delete(node*); // функция для удаления заданного элемента
    void DelAfter(node*); // функция для удаления элемента после заданного
    node* PoiskForward(int);// функция для поиска элемента списка в прямом направлении
    node* PoiskBack(int); // функция для поиска элемента списка в обратном направлении
};
void main() // главная функция программы
{
    setlocale(LC_ALL, "Rus"); // установка локали на русский язык
    Spisok A; // создание объекта класса Spisok
    node* Res; // указатель на элемент списка
    int el, el1; // переменные для ввода элементов списка

    A.Postroenie(); // построение списка
    A.VyvodForward(); A.VyvodBack(); // вывод списка в прямом и обратном направлениях

    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется вставка: ";
    cin >> el; //ввод элемента, после которого будет производится вставка
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;  //ввод элемента, который будем вставлять
    Res = A.PoiskForward(el); // поиск элемента после которого будет производится вставка
    if (Res != NULL) // если такой элемент найден
    {
        A.InsAfter(el1, Res);  // вставка нового элемента после заданного элемента
        A.VyvodForward(); A.VyvodBack(); // вывод списка в прямом и обратном направлениях
    }
    else  cout << "Звена с заданным элементом в списке нет!\n";  // если элемент не найден

    cout << "Введите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el; //ввод элемента, перед которым будем вставлять элемент
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1; //ввод элемента, который будем вставлять
    Res = A.PoiskBack(el); // поиск элемента, перед которым будем вставлять новый элемент
    if (Res != NULL) // если такой элемент найден
    {
        A.InsBefore(el1, Res);  //вставка нового элемента перед заданным элементом
        A.VyvodForward(); A.VyvodBack(); // вывод списка в прямом и обратном направлениях
    }
    else  cout << "Звена с заданным элементом в списке нет!\n"; // если такой элемент не найден

    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется удаление: ";
    cin >> el; // ввод элемента, после которого будет производиться удаление
    Res = A.PoiskForward(el); // поиск элемента, после которого будет производиться удаление
    if (Res != NULL) // если такой элемент найден
    {
        A.DelAfter(Res); // удаление элемента после заданного элемента
        A.VyvodForward(); A.VyvodBack(); // вывод списка в прямом и обратном направлениях
    }
    else  cout << "Звена с заданным элементом в списке нет!\n"; //если такой элемент не найден

    cout << "Введите элемент звена, которое ";
    cout << "надо удалить: ";
    cin >> el; // ввод элемента который собираемся удалять
    Res = A.PoiskForward(el); // поиск элемента, который собираемся удалять
    if (Res != NULL) //если такой элемент найден
    {
        A.Delete(Res); //удаление заданного элемента
        A.VyvodForward(); A.VyvodBack(); // вывод списка в прямом и обратном направлениях
    }
    else  cout << "Звена с заданным элементом в списке нет!\n"; //если такой элемент не найден

    A.Ochistka(); //очиста списка

    cout << "\n"; // переход на новую строку
    system("PAUSE");//ожидание нажатия любой клавиши
}
void Spisok::Postroenie()
//Построение двунаправленного списка с заглавным звеном:
// nsp - указатель на начало списка,
// ksp - указатель на конец списка.
{
    node* rsp; // указатель на текущее звено списка
    int el; // переменная для ввода элементов

    nsp = new(node); // создание заглавного звена
    rsp = nsp; //текущее звено указывает на начало списка
    (*nsp).pred = NULL; (*nsp).sled = NULL; //настройка указателей
    cout << "Вводите последовательность:\n";
    cin >> el; //ввод элемента последовательности
    while (el != 0) //пока не введен ноль
    {
        (*rsp).sled = new(node); // создание нового звена
        (*((*rsp).sled)).pred = rsp; // установка указателя на предыдущее звено
        rsp = (*rsp).sled; // перемещение указателя на следующее звено
        (*rsp).sled = NULL; (*rsp).elem = el; // установка значения элемента звена
        cin >> el; //ввод элемента последовательности
    }
    ksp = rsp; // установка указателя на конец списка

}

void Spisok::VyvodForward()
//Вывод содержимого двунаправленного списка от его начала.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
    node* rsp; // Объявление указателя на звено списка
    rsp = (*nsp).sled; // Инициализация указателя на первый элемент списка (после заголовочного звена)
    cout << "Двунаправленный список содержит: ";
    while (rsp != NULL)// Пока указатель не указывает на нулевой указатель
    {
        cout << (*rsp).elem << " ";// Вывод значения элемента на экран
        rsp = (*rsp).sled;// Перемещение указателя на следующий элемент
    }
    cout << endl; // Вывод символа перевода строки
}

void Spisok::VyvodBack()
//Вывод содержимого двунаправленного списка от его конца.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
    node* rsp; // Объявление указателя на звено списка

    rsp = ksp; // Инициализация указателя на последний элемент списка
    cout << "Двунаправленный список в обратном порядке: ";
    while ((*rsp).pred != NULL) // Пока указатель не указывает на нулевой указатель
    {
        cout << (*rsp).elem << " "; ;// Вывод значения элемента на экран
        rsp = (*rsp).pred; // Перемещение указателя на следующий элемент
    }
    cout << endl; // Вывод символа перевода строки
}

node* Spisok::PoiskForward(int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
    node* q;  //рабочий указатель
    node* Res; //указатель для найденног элемента

    Res = NULL; q = (*nsp).sled; //Инициализация указателя на NULL и начало поиска с первого элемента списка
    while (q != NULL && Res == NULL) //Пока не дошли до конца списка и не нашли элемент el, идем по списку
        if ((*q).elem == el) Res = q; // есил элемент найден, записываем результат в Res
        else  q = (*q).sled; // переходим к следующему элементу
    return Res; //Возвращаем найденный элемент или NULL, если не найден
}

node* Spisok::PoiskBack(int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
    node* q; //рабочий указатель
    node* Res; //указатель для найденног элемента

    Res = NULL; q = ksp; //Инициализация указателя на NULL и начало поиска с первого элемента списка
    while (q != NULL && Res == NULL) //Пока не дошли до конца списка и не нашли элемент el, идем по списку
        if ((*q).elem == el) Res = q; // есил элемент найден, записываем результат в Res
        else  q = (*q).pred; // переходим к следующему элементу
    return Res; //Возвращаем найденный элемент или NULL, если не найден
}

void Spisok::InsAfter(int el, node* Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, после звена, на которое указывает Res.
{
    node* q; //рабочий указатель

    q = new(node); // создание нового звена
    (*q).elem = el; // инициализация информационного поля звена новым значением
    if ((*Res).sled != NULL) // если Res не является последним звеном списка
    {
        (*q).sled = (*Res).sled; // установка указателя следующего звена нового звена на следующий за Res звеньев
        (*q).pred = (*(*Res).sled).pred; // установка указателя предыдущего звена нового звена на предыдущий за Res звеньев
        (*(*Res).sled).pred = q; // установка указателя предыдущего звена следующего за Res звена на q
        (*Res).sled = q; // установка указателя следующего звена Res на q
    }
    else // если Res является последним звеном списка
    {
        (*q).sled = NULL; // установка указателя следующего звена нового звена на NULL
        (*q).pred = Res; // установка указателя предыдущего звена нового звена на Res
        ksp = q; // изменение указателя на последний элемент списка на q
        (*Res).sled = q; // установка указателя следующего звена Res на q
    }

}

void Spisok::InsBefore(int el, node* Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, перед звеном, на которое указывает Res.
{
    node* q; //рабочий указатель
    q = new(node); // создание нового звена
    (*q).elem = el; // инициализация информационного поля звена новым значением
    (*q).sled = (*(*Res).pred).sled; // новый элемент "соединяется" со следующим элементом после Res
    (*q).pred = (*Res).pred; // предыдущий элемент перед Res становится предыдущим для нового элемента
    (*(*Res).pred).sled = q;  // следующим элементом после предыдущего элемента становится новый элемент
    (*Res).pred = q; // элемент Res теперь предыдущий для нового элемента
}

void Spisok::Delete(node* Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на удаляемое звено.
{
    if ((*Res).sled != NULL) // если элемент не последний
    {
        (*(*Res).sled).pred = (*Res).pred; // предыдущим для следующего элемента после Res становится предыдущий элемент Res
        (*(*Res).pred).sled = (*Res).sled; // следующим за предыдущим элементом становится следующий элемент Res
        delete Res; // удаление элемента
    }
    else // если элемент последний
    {
        (*(*Res).pred).sled = NULL; // предыдущий элемент становится последним
        ksp = (*ksp).pred; // конечный элемент списка становится предпоследним
        delete Res; // удаление элемента
    }
}

void Spisok::DelAfter(node* Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на звено, предыдущее удаляемому.
{
    node* q; //рабочий указатель

    if ((*Res).sled == NULL) // Проверяем, является ли удаляемое звено последним звеном в списке.
    {
        cout << "Указано последнее звено!\n";
    }
    else
    {
        if ((*(*Res).sled).sled != NULL) // Если удаляемое звено не является последним, то перенаправляем указатели вокруг него.
        {
            q = (*Res).sled; // сохраняем указатель на удаляемое звено.
            (*(*(*Res).sled).sled).pred = Res; // перенаправляем указатель на предыдущее звено.
            (*Res).sled = (*(*Res).sled).sled; // перенаправляем указатель на следующее звено.
            delete q; // удаляем звено.
        }
        else // Если удаляемое звено является последним, то просто удаляем его и перенаправляем указатель на последнее звено в списке на предыдущее звено.
        {
            q = (*Res).sled; // сохраняем указатель на удаляемое звено.
            (*Res).sled = NULL; // перенаправляем указатель на следующее звено на NULL.
            ksp = (*ksp).pred; // перенаправляем указатель на последнее звено на предыдущее звено.
            delete q; // удаляем звено.
        }
    }

}

void Spisok::Ochistka()
//Удаление двунаправленного списка из памяти.
// nsp - указатель на заглавное звено списка,
// ksp - указатель на последнее звено списка.
{
    node* q, * q1;  // рабочие указатели

    q = nsp; // устанавливаем указатель q на заглавное звено списка.
    q1 = (*q).sled; // устанавливаем указатель q1 на следующее звено.
    while (q1 != NULL) // пока не достигнем конца списка.
    {
        q = q1; // перемещаем указатель q на следующее звено.
        q1 = (*q1).sled; // перемещаем указатель q1 на следующее звено.
        delete q; // удаляем звено.
    }
    delete nsp; // удаляем заглавное звено списка.
    nsp = ksp = NULL; // устанавливаем указатели на NULL.

}
*/