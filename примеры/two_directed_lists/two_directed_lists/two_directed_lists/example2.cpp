#include <iostream> //Подключаем библиотеку iostream, которая позволяет вводить и выводить данные
using namespace std; //Используем стандартное пространство имён

struct node//Определяем структуру node, представляющую звено списка
{
    int elem; //Значение элемента звена
    node* sled; //Указатель на следующее звено
    node* pred; //Указатель на предыдущее звено
};

class Spisok //Определяем класс Spisok
{
private:
    node* nsp; //Указатель на начало списка
public:
    Spisok() { nsp = NULL; } //Конструктор класса
    //Методы класса
    void BuiltRing(); //Построение кольца
    void VyvodLeftRight(); //Вывод содержимого кольца по часовой стрелке
    void VyvodRightLeft(); //Вывод содержимого кольца против часовой стрелки
    void InsAfter(node*, int); //Вставка нового звена после указанного звена
    void InsBefore(node*, int); //Вставка нового звена перед указанным звеном
    void Delete(node*); //Удаление указанного звена
    void DelAfter(node*); //Удаление звена, следующего за указанным звеном
    node* SearchRing(int); //Поиск звена по указанному значению элемента
    void Ochistka(); //Удаление списка из памяти

};

void main() //Основная функция программы
{
    setlocale(LC_ALL, "Rus"); //Устанавливаем локаль для корректного отображения символов на кириллице
    Spisok A; //Создаем объект класса Spisok

    node* Res; //Объявляем указатель на звено
    int el, el1; // Объявляем две переменные для хранения значений элементов звенов
    A.BuiltRing(); //Вызываем метод BuiltRing() для построения кольца

    cout << "Содержимое кольца 'по часовой стрелке': \n";
    A.VyvodLeftRight(); // Выводм содержимое кольца по часовой стрелке
    cout << "Содержимое кольца 'против часовой стрелки': \n";
    A.VyvodRightLeft(); // Выводим содержимое кольца против часовой стрелки

    cout << "Введите элемент звена, после которого осуществляется вставка: ";
    cin >> el; //Вводим элемент, после которого будет осуществлятся вставка
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1; // Вводи элемент, который будем втавлять

    cout << "Введите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el;// вводим элемент, перед которым будем вставлять 
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1; //вводим элемент, который будем втавлять
    Res = A.SearchRing(el); //Вызываем метод SearchRing() для поиска звена по указанному значению элемента
    if (Res != NULL) // Если звено найдено
    {
        A.InsBefore(Res, el1); A.VyvodLeftRight(); // вставляем новое звено перед ним и выводим содержимое кольца по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n"; // Иначе выводим сообщение об ошибке


    Res = A.SearchRing(el); //Вызываем метод SearchRing() для поиска звена по указанному значению элемента
    if (Res != NULL) // Если звено найдено
    {
        A.InsBefore(Res, el1); A.VyvodLeftRight();  // вставляем новое звено после него и выводим содержимое кольца по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n"; // Иначе выводим сообщение об ошибке

    // Запрашиваем у пользователя элемент звена, которое необходимо удалить
    cout << "Введите элемент звена, который ";
    cout << "надо удалить: ";
    cin >> el; // ввод элемента, который будем удалять
    Res = A.SearchRing(el); // Ищем звено, которое необходимо удалить
    if (Res != NULL) // Если звено найдено
    {
        A.Delete(Res); A.VyvodLeftRight(); // удаляем его и выводим содержимое кольца по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n"; // Иначе выводим сообщение об ошибке

    // Запрашиваем у пользователя элемент звена после которого необходимо удалить элемент
    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется удаление: ";
    cin >> el; // ввод элемента, после которого будет производиться удаление
    Res = A.SearchRing(el); // Ищем звено, после которого будем удалять
    if (Res != NULL) // Если звено найдено
    {
        A.DelAfter(Res); A.VyvodLeftRight(); // удаляем его и выводим содержимое кольца по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n"; // Иначе выводим сообщение об ошибке
    A.Ochistka(); //очищам список 

    cout << "\n";  //вводим символ перехода на новую строку
    system("PAUSE"); //ожидания нажатия любой клавиши
}

void Spisok::BuiltRing()
// Построение двунаправленного кольцевого списка nsp
//          с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* r; // указатель на текущее звено списка
    int el; // переменная для ввода элементов списка
    // Построим заглавное звено кольцевого списка.
    nsp = new(node); // выделяем память под заглавное звено
    r = nsp; // устанавливаем указатель на текущее звено на заглавное
    (*nsp).pred = NULL; (*nsp).sled = NULL; // устанавливаем предыдущий и следующий элементы заглавного звена в NULL

    cout << "Вводите элементы списка: \n";
    cin >> el; //ввод элемента списка

    while (el != 0) // пока не введен ноль
    {
        (*r).sled = new (node); // выделяем память под следующее звено
        (*((*r).sled)).pred = r; // устанавливаем указатель на предыдущее звено
        r = (*r).sled; // переносим указатель на текущее звено на следующее
        (*r).sled = NULL; (*r).elem = el; // устанавливаем указатель на следующее звено в NULL и записываем элемент списка
        cin >> el; // считываем следующий элемент
    }

    // А теперь - образуем кольцевой список!
    if ((*nsp).sled != NULL) // если список не пуст
    {
        (*((*nsp).sled)).pred = r; // устанавливаем указатель на предыдущее звено последнего элемента списка на текущий
        (*r).sled = (*nsp).sled; // устанавливаем указатель на следующее звено последнего элемента на первый элемент списка
    }
    else // если список пуст
        cout << "Кольцевой список пуст!\n";

}

void Spisok::VyvodLeftRight()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "по часовой стрелке".
// nsp - указатель на заглавное звено списка.
{
    node* r; // указатель на текущее звено списка.
    cout << "Кольцевой список: ";
    if ((*nsp).sled != NULL) // Если список не пуст
    {
        cout << (*((*nsp).sled)).elem << " "; // Выводим значение первого элемента списка
        r = (*((*nsp).sled)).sled; // Устанавливаем указатель на следующий элемент списка
        while (r != (*nsp).sled) // Проходим по всем элементам списка до возврата к первому элементу
        {
            cout << (*r).elem << " "; // Выводим значение текущего элемента
            r = (*r).sled; // Устанавливаем указатель на следующий элемент списка
        }
        cout << endl;
    }
    else // Если список пуст
    {
        cout << "пуст!";
    }

}

void Spisok::VyvodRightLeft()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "против часовой стрелки".
// nsp - указатель на заглавное звено списка.
{
    node* r;  //указатель на текущее звено списка.

    cout << "Кольцевой список: ";
    if ((*nsp).sled != NULL) // если список не пуст
    {
        cout << (*((*((*nsp).sled)).pred)).elem << " "; // выводим последний элемент
        r = (*((*((*nsp).sled)).pred)).pred; // переходим к следующему элементу
        while (r != (*((*nsp).sled)).pred)
        {
            cout << (*r).elem << " "; r = (*r).pred; // выводим оставшиеся элементы в обратном порядке
        }
        cout << endl; // символ перехода на новую строку 
    }
    else cout << "пуст!"; //  Если список пуст, то выводим соответствующее сообщение.
}

node* Spisok::SearchRing(int el)
// Поиск элемента el в кольцевом двунаправленном списке
//             с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* q; // указатель на текущий узел списка
    node* p; // указатель на заглавное звено списка
    node* Res; // указатель на узел, содержащий элемент "el"

    Res = NULL; // инициализация указателя результата
    p = nsp; // инициализация указателя заглавного звена списка
    if ((*((*p).sled)).elem == el) // проверяем первый элемент списка
        Res = (*p).sled; // сохраняем указатель на узел
    else
    {
        q = (*((*p).sled)).sled; // указатель на следующий узел списка
        // ищем элемент в списке, начиная со второго элемента
        while (q != (*p).sled && Res == NULL)
        {
            if ((*q).elem == el) // если элемент найден
                Res = q; // сохраняем указатель на узел
            else
                q = (*q).sled; // иначе переходим к следующему узлу
        }
    }
    return Res; // возвращаем указатель на узел с искомым элементом

}

void Spisok::InsAfter(node* Res, int el)
// Вставление в кольцевой двунаправленный список звена
// с информационным полем el после  звена, на  которое
// указывает ссылка Res.
{
    node* q; // указатель на текущий узел списка

    q = new(node); // выделяем память для нового звена
    (*q).elem = el; // устанавливаем информационное поле нового звена
    (*q).sled = (*Res).sled; // настраиваем связи между узлами
    (*q).pred = (*(*Res).sled).pred; // настраиваем связи между узлами
    (*(*Res).sled).pred = q; (*Res).sled = q; // настраиваем связи между узлами
}

void Spisok::InsBefore(node* Res, int el)
// Вставка в кольцевой двунаправленный список звена
// с информационным полем el перед звеном, на  которое
// указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q; // указатель на текущий узел списка

    q = new(node); // выделение памяти для нового звена списка
    (*q).elem = el; // сохранение значения нового элемента в информационное поле нового звена
    (*q).sled = (*(*Res).pred).sled; // связывание нового звена с предыдущим звеном в списке
    (*q).pred = (*Res).pred; // связывание нового звена с звеном, на которое указывает ссылка Res
    (*(*Res).pred).sled = q; // связывание предыдущего звена со вставляемым
    (*Res).pred = q; // связывание звена, на которое указывает ссылка Res со вставляемым
    if (Res == (*nsp).sled) // Если Res указывает на первый элемент списка, то необходимо обновить указатель на первый элемент
    {
        (*nsp).sled = q; // новый элемент становится первым в списке
    }

}

void Spisok::Delete(node* Res)
// Удаление из кольцевого двунаправленного списка
// звена, на которое указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
if ((*Res).sled == Res)
{
    // Если удаляем единственное звено в списке:
    (*nsp).sled = NULL; delete Res;
}
else
{
    // Если удаляем звено, которое не единственное в списке:
    (*(*Res).sled).pred = (*Res).pred; // Перестраиваем связи между звеньями
    (*(*Res).pred).sled = (*Res).sled; // Перестраиваем связи между звеньями
    if ((*nsp).sled == Res)
        // Если удаляем первое звено кольца:
        (*nsp).sled = (*Res).sled;
    delete Res;
}
}


void Spisok::DelAfter(node* Res)
// Удаление из кольцевого двунаправленного списка звена,
// расположенного  после  звена, на  которое  указывает
// ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q; // указатель на текущий узел списка

    if ((*Res).sled == Res) // проверка, что Res - последнее звено кольца
    {
        (*nsp).sled = NULL; // кольцо разрушено, список стал пустым
        delete Res; // удаляем Res
    }
    else // Res - не последнее звено кольца
    {
        q = (*Res).sled; // сохраняем указатель на удаляемое звено
        (*(*(*Res).sled).sled).pred = (*(*Res).sled).pred; // связываем предыдущее звено со следующим
        (*Res).sled = (*(*Res).sled).sled; // связываем текущее звено со следующим
        if ((*(*nsp).sled).pred == Res)
            // Удаляем "последнее" звено кольца.
            (*nsp).sled = (*Res).sled; // если Res - предпоследнее звено, то следующее звено станет последним
        delete q; // удаляем звено, которое находилось после Res
    }

}

void Spisok::Ochistka()
{
    node* q, * q1;
    q = (*((*nsp).sled)).sled; // Изначально q указывает на первый элемент списка.
    q1 = (*q).sled; // q1 указывает на следующий элемент после q.
    while (q1 != (*((*nsp).sled)).sled) // Проходим по списку и удаляем каждый элемент.
    {
        delete q;
        q = q1;
        q1 = (*q1).sled;
    }
    delete q; // Удаляем последний элемент.
    delete nsp; // Удаляем заглавное звено списка.
}
