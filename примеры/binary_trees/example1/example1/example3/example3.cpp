//Пример.Нерекурсивное построение бинарного дерева и его изображение на экране дисплея.

#include <iostream> // подключение библиотеки ввода/вывода
using namespace std; // объявление пространства имен std

struct node
{
    int Key; // Ключ вершины
    int Count; // Количество вершин с таким же ключом
    node* Left; // Указатель на левое поддерево
    node* Right; // Указатель на правое поддерево
};

struct no // Звено стека
{
    node* elem; // Информационное поле.
    int ch; // Уровень вершины.
    no* sled; // Указатель на вершину.
};

class TREE// Объявляем класс для бинарного дерева
{
private:
    node* Tree;// Указатель на корень дерева
    void PushStack(no**, node**, int*);// Помещение звена с элементами *el и n в
    // стек. *stk - указатель на стек.
    void PopStack(no**, node**, int*); // Извлечение из стека звена
    // с элементами *t и n.
    // *stk - указатель на стек
    void VyvodStack(no**); // Вывод содержимого стека на экран дисплея.
    // *stk - указатель на стек.

public:
    TREE() { Tree = new(node); (*Tree).Right = NULL; }// Конструктор класса TREE, Создает объект дерева, устанавливает его корневой элемент, а правый потомок устанавливается в NULL
    node* GetTreeRight() { return (*Tree).Right; }// Метод GetTreeRight() Возвращает указатель на правого потомка корневого элемента дерева
    void  TreeSearch(int); // Поиск вершины с информационным полем  el в дереве с
    // последующим (в случае неудачного поиска!) включением
    // в дерево. Tree - указатель на корень дерева.

    void  VyvodTree(node*); //Построение дерева, заданного указателем t,
    //на экране дисплея (нерекурсивный алгоритм).

};

void main()//вызов главной функции с которой начинается выполнение программы
{
    setlocale(LC_ALL, "Rus");// устанавливаем локаль для вывода на русском языке

    TREE A; // создаем объект класса TREE
    int el;//переменная для ввода эелментов

    cout << "Вводите значения информационных полей вершин: " << endl; // выводим приглашение на ввод элементов
    cin >> el; // считываем первый элемент
    while (el != 0) // запускаем цикл ввода элементов, пока не введем 0
    {
        A.TreeSearch(el); // добавляем элемент в дерево
        cin >> el; // считываем следующий элемент
    }
    A.VyvodTree(A.GetTreeRight()); // выводим дерево на экран

    cout << "\n"; // выводим пустую строку
    system("PAUSE"); // ожидаем ввода пользователем любой клавиши

}

void TREE::TreeSearch(int el)
// Поиск вершины с информационным полем  el в дереве с
// последующим (в случае неудачного поиска!) включением
// в дерево. Tree - указатель на корень дерева.
{
    node* p1, * p2; // указатели на родителя и текущую вершину
    int d; // флаг направления движения по дереву

    p2 = Tree; // начинаем поиск с корня
    p1 = (*p2).Right; // идем к правому поддереву
    d = 1; // инициализируем флаг направления движения
    while (p1 != NULL && d != 0) // пока не дошли до конца дерева или не нашли искомый элемент
    {
        p2 = p1; // переходим на следующую вершину
        if (el < (*p1).Key) { p1 = (*p1).Left; d = -1; } // если искомый элемент меньше, чем текущий, идем налево
        else if (el > (*p1).Key) { p1 = (*p1).Right; d = 1; } // если искомый элемент больше, чем текущий, идем направо
        else d = 0; // если элемент найден, устанавливаем флаг в 0
    }

    if (d == 0) (*p1).Count = (*p1).Count + 1; // если элемент найден, увеличиваем его счетчик
    else // если элемент не найден
    {
        p1 = new(node); // выделяем память под новую вершину
        (*p1).Key = el; // задаем ключ новой вершины
        (*p1).Left = NULL; // инициализируем указатель на левое поддерево
        (*p1).Right = NULL; // инициализируем указатель на правое поддерево 
        (*p1).Count = 1;// Счетчик встречаемости равен 1.
        if (d < 0) (*p2).Left = p1; // Добавляем новую вершину в левое поддерево родителя.
        else  (*p2).Right = p1; // Добавляем новую вершину в правое поддерево родителя.
    }
}


void TREE::VyvodTree(node* t)
//Построение дерева, заданного указателем t,
//на экране дисплея (нерекурсивный алгоритм).
{
    no* stk, * stk1; // Указатели на стеки
    node* u; // Указатель на текущую вершину
    int i, n; // Счетчики
    stk = stk1 = NULL; // Инициализация указателей на стеки
    n = 0; // Инициализация счетчика
    while (t != NULL) // Пока не обошли все вершины дерева
    {
        // Добавляем текущую вершину во второй стек
        PushStack(&stk1, &t, &n);
        if ((*t).Right != NULL) // Если есть правый потомок
        {
            if ((*t).Left != NULL) // Если есть и левый потомок
                PushStack(&stk, &((*t).Left), &n); // Добавляем левый потомок в первый стек
            t = (*t).Right; // Переходим к правому потомку
        }
        else // Если нет правого потомка
        {
            if ((*t).Left != NULL) // Если есть левый потомок
            {
                if (stk1 != NULL) // Если во втором стеке есть элементы
                {
                    PopStack(&stk1, &u, &n); // Извлекаем последний элемент из второго стека
                    for (i = 0; i <= n; i++) cout << " "; // Отступы для вывода на экран
                    cout << (*u).Key << endl; // Выводим значение ключа на экран
                }
                t = (*t).Left; // Переходим к левому потомку
            }
            else if (stk == NULL) // Если нет левого потомка и первый стек пуст
                t = NULL; // Завершаем цикл
            else // Если нет левого потомка и первый стек не пуст
            {
                // Пока вершина в первом стеке не является родительской для текущей вершины
                while ((*stk).elem != (*((*stk1).elem)).Left)
                {
                    PopStack(&stk1, &u, &n); // Извлекаем последний элемент из второго стека
                    for (i = 0; i <= n; i++) cout << " "; // Отступы для вывода на экран
                    cout << (*u).Key << endl; // Выводим значение ключа на экран
                }
                PopStack(&stk1, &u, &n); // Извлекаем последний элемент из второго стека
                for (i = 0; i <= n; i++) cout << " "; // Отступы для вывода на экран
                cout << (*u).Key << endl; // Выводим значение ключа на экран
                PopStack(&stk, &t, &n); // Извлекаем последний элемент из первого стека
            }
        }

        n = n + 1;//увеличение счетчика на единицу
    }
    VyvodStack(&stk1);//вывод стека на экран
}


void TREE::PushStack(no** stk, node** el, int* n)
// Функция для помещения звена с элементами *el и *n в стек.
// stk - указатель на стек.
{
    no* q;//объявление рабочего указателя
    q = new(no); // Выделяем память для нового звена в стеке.
    (*q).elem = *el; // Устанавливаем указатель на элемент в звене стека.
    (*q).ch = *n; // Устанавливаем число потомков у узла в звене стека.
    (*q).sled = *stk; // Устанавливаем указатель на предыдущее звено стека в текущее.
    *stk = q; // Устанавливаем указатель на текущее звено стека.
}

void TREE::PopStack(no** stk, node** t, int* n)
// Функция для извлечения из стека звена с элементами *t и *n.
// stk - указатель на стек.
{
    no* q;//объявление рабочего указателя
    if (*stk != NULL) // Если стек не пустой
    {
        *t = (**stk).elem; // Устанавливаем указатель на элемент из звена стека.
        *n = (**stk).ch; // Устанавливаем число потомков у узла из звена стека.
        q = *stk; // Сохраняем указатель на текущее звено стека.
        *stk = (**stk).sled; // Устанавливаем указатель на предыдущее звено стека в текущее.
        delete q; // Освобождаем память для звена, которое удаляем из стека.
    }
}

void TREE::VyvodStack(no** stk)
// Вывод содержимого стека на экран дисплея.
// *stk - указатель на стек.
{
    node* k; // указатель на узел
    int i, n; // переменные для отступов и уровня узла

    while (*stk != NULL)
    {
        k = (**stk).elem; // получаем элемент из вершины стека
        n = (**stk).ch; // получаем количество пробелов для отступа
        for (i = 0; i <= n; i++) cout << " "; // выводим отступы
        cout << (*k).Key << endl; // выводим ключ узла
        *stk = (**stk).sled; // переходим к следующему элементу стека
    }
}
