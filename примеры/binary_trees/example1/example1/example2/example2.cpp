//Пример программы с использованием бинарного дерева поиска

#include <iostream>// Включаем заголовочный файл для работы со стандартным вводом/выводом
using namespace std;// объявление пространства имен std

struct node // Объявляем структуру для вершины дерева
{
    int Key; // Ключ вершины
    int Count; // Количество вершин с таким же ключом
    node* Left; // Указатель на левое поддерево
    node* Right; // Указатель на правое поддерево
};

class TREE// Объявляем класс для бинарного дерева
{
private:
    node* Tree; // Указатель на корень дерева
    void Search(int, node**); // Поиск вершины с ключом int в дереве со вставкой
public:
    TREE() { Tree = NULL; } // Конструктор по умолчанию, инициализирующий корень дерева как NULL
    node** GetTree() { return &Tree; } // Получение указателя на корень дерева
    void BuildTree(); // Построение дерева
    void CleanTree(node**); // Очистка дерева
    void ObhodEnd(node**); // Концевой обход дерева
    void ObhodLeft(node**); // Левосторонний обход дерева
    void ObhodBack(node**); // Обратный обход дерева
    void Vyvod(node**, int); // Изображение дерева на экране дисплея
    int Height(node**); // Определение высоты бинарного дерева
};

void main() {//вызов главной функции с которой начинается выполнение программы
    setlocale(LC_ALL, "Rus"); // Устанавливаем локаль для корректной работы с русским языком
    TREE A; // Создаем объект класса TREE
    A.BuildTree(); // Вызываем метод для построения бинарного дерева
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0); // Выводим дерево на экран
    cout << "\nВысота дерева:" << A.Height(A.GetTree()) << endl; // Вычисляем высоту дерева и выводим ее на экран
    cout << "\nЛевосторонний обход дерева: ";
    A.ObhodLeft(A.GetTree()); // Обходим дерево слева направо
    cout << "\nКонцевой обход дерева: ";
    A.ObhodEnd(A.GetTree()); // Обходим дерево в порядке концевых вершин
    cout << "\nОбратный обход дерева: ";
    A.ObhodBack(A.GetTree()); // Обходим дерево справа налево
    A.CleanTree(A.GetTree()); // Очищаем память, выделенную под дерево
    cout << "\n";
    system("PAUSE");
}


void TREE::BuildTree()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
    int el;//переменная для ввода эелментов

    cout << "Вводите ключи вершин дерева ...\n"; // Выводим приглашение на ввод ключей вершин дерева.
    cin >> el;
    while (el != 0) // Запускаем цикл ввода ключей до тех пор, пока не будет введен 0.
    {
        Search(el, &Tree); // Ищем вершину с ключом el в дереве и вставляем ее, если ее нет.
        cin >> el; // Запрашиваем новый ключ.
    }
}

void TREE::Search(int x, node** p)
// Поиск вершины с ключом x в дереве со вставкой (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
    if (*p == NULL) // Если указатель на корень дерева равен NULL, значит вершины в дереве нет и ее нужно вставить.
    {
        *p = new(node); // Выделяем память для новой вершины и присваиваем указателю на корень дерева адрес этой вершины.
        (**p).Key = x; // Присваиваем ключ новой вершине.
        (**p).Count = 1; // Присваиваем начальное значение счетчика.
        (**p).Left = NULL; // Присваиваем значения NULL указателю на левое поддерево новой вершины.
        (**p).Right = NULL; // Присваиваем значения NULL указателю на правое поддерево новой вершины.
    }
    else if (x < (**p).Key) // Если искомый ключ меньше ключа текущей вершины, идем в левое поддерево.
    {
        Search(x, &((**p).Left)); // Рекурсивно вызываем функцию поиска для левого поддерева.
    }
    else if (x > (**p).Key) // Если искомый ключ больше ключа текущей вершины, идем в правое поддерево.
    {
        Search(x, &((**p).Right)); // Рекурсивно вызываем функцию поиска для правого поддерева.
    }
    else // Если ключ уже существует в дереве, увеличиваем счетчик этой вершины.
    {
        (**p).Count = (**p).Count + 1;
    }
}


// Левосторонний обход дерева.
// w - указатель на корень дерева.
void TREE::ObhodLeft(node** w)
{
    if (*w != NULL)//если дерево не пустое
    {
        cout << (**w).Key << " "; // вывод ключа
        ObhodLeft(&((**w).Left)); // обход левого поддерева
        ObhodLeft(&((**w).Right)); // обход правого поддерева
    }
}

// Концевой обход дерева.
// w - указатель на корень дерева.
void TREE::ObhodEnd(node** w)
{
    if (*w != NULL)//если дерево не пустое
    {
        ObhodEnd(&((**w).Left)); // обход левого поддерева
        ObhodEnd(&((**w).Right)); // обход правого поддерева
        cout << (**w).Key << " "; // вывод ключа
    }
}

// Обратный обход дерева.
// w - указатель на корень дерева.
void TREE::ObhodBack(node** w)
{
    if (*w != NULL)//если дерево не пустое
    {
        ObhodBack(&((**w).Left)); // обход левого поддерева
        cout << (**w).Key << " "; // вывод ключа
        ObhodBack(&((**w).Right)); // обход правого поддерева
    }
}

void TREE::CleanTree(node** w)
//Очистка дерева.
//*w - указатель на корень дерева.
{
    if (*w != NULL)//если дерево не пустое
    {
        CleanTree(&((**w).Left)); // Очистка левого поддерева.
        CleanTree(&((**w).Right)); // Очистка правого поддерева.
        delete w; // Освобождение памяти, занятой корнем поддерева.
    }
}

void TREE::Vyvod(node** w, int l)
//Изображение дерева *w на экране дисплея
// (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;

    if (*w != NULL)//если дерево не пустое
    {
        Vyvod(&((**w).Right), l + 1); // Рекурсивный вызов функции для правого поддерева с увеличением отступа.
        for (i = 1; i <= l; i++) cout << "   "; // Вывод отступа для текущего уровня дерева.
        cout << (**w).Key << endl; // Вывод значения текущей вершины.
        Vyvod(&((**w).Left), l + 1); // Рекурсивный вызов функции для левого поддерева с увеличением отступа.
    }

}

int TREE::Height(node** w)
//Определение высоты бинарного дерева.
//*w - указатель на корень дерева.
{
    int h1, h2;
    if (*w == NULL) return (-1); // Для пустого дерева высота равна -1.
    else
    {
        h1 = Height(&((**w).Left)); // Определение высоты левого поддерева.
        h2 = Height(&((**w).Right)); // Определение высоты правого поддерева.
        if (h1 > h2) return (1 + h1); // Высота дерева равна высоте левого поддерева + 1.
        else return (1 + h2); // Высота дерева равна высоте правого поддерева + 1.
    }
}
