//пример программы, иллюстрирующей поиск заданной вершины в дереве, добавление вершины в дерево, удаление вершины из дерева.

#include <iostream> // подключение библиотеки ввода/вывода
using namespace std; // объявление пространства имен std

#define TRUE 1  //определение константы TRUE равной 1
#define FALSE 0 //определение константы FALSE равной 0
struct  node
{
    int Key; // Ключ вершины
    int Count; // Количество вершин с таким же ключом
    node* Left; // Указатель на левое поддерево
    node* Right; // Указатель на правое поддерево
};

class TREE
{
private:
    node* Tree;//Указатель на корень дерева.
    node* Res;//Указатель на найденную вершину.
    int B; //Признак нахождения вершины в дереве.
    //Поиск вершины в дереве (рекурсивный алгоритм).
    void Search(int, node**); //Поиск звена x в бинарном дереве
    //вершина с заданным ключом имеет две исходящие дуги
    void Delete_1(node**, node**);
public:
    TREE() { Tree = NULL; }
    node** GetTree() { return &Tree; }
    void  BuildTree();//Построение бинарного дерева.
    //Вывод дерева на экран (рекурсивный алгоритм).
    void Vyvod(node**, int);
    //Поиск вершины в дереве (нерекурсивный алгоритм).
    int Poisk(int);
    //Поиск вершины в дереве (рекурсивный алгоритм).
    node* Poisk_1(int, node**);
    //Добавление вершины в дерево (нерекурсивный алгоритм).
    void Addition(int);
    // Удаление вершины из дерева.
    void Delete(node**, int);
};

void main()//вызов главной функции с которой начинается выполнение программы
{
    setlocale(LC_ALL, "Rus"); // установка локали, чтобы корректно работали кириллические символы в консоли
    TREE A; // создание объекта класса TREE
    int el; // переменная для хранения ключа вершины

    A.BuildTree(); // построение дерева
    A.Vyvod(A.GetTree(), 0); // вывод дерева на экран

    cout << "Введите ключ вершины, которую нужно найти в дереве: ";
    cin >> el; // ввод ключа вершины для поиска
    if (A.Poisk(el)) // если вершина найдена
        cout << "В дереве есть такая вершина!\n"; // вывод сообщения об успешном поиске
    else
        cout << "В дереве нет такой вершины!\n"; // вывод сообщения о неудачном поиске
    cout << "Введите ключ вершины, которую нужно найти в дереве: ";
    cin >> el; // ввод ключа вершины для поиска
    if (A.Poisk_1(el, A.GetTree()) != NULL) // если вершина найдена
        cout << "В дереве есть такая вершина!\n"; // вывод сообщения об успешном поиске
    else
        cout << "В дереве нет такой вершины!\n"; // вывод сообщения о неудачном поиске

    cout << "Введите ключ добавляемой вершины: ";
    cin >> el; // ввод ключа добавляемой вершины
    A.Addition(el); // добавление вершины в дерево
    A.Vyvod(A.GetTree(), 0); // вывод дерева на экран

    cout << "Введите ключ удаляемой вершины: ";
    cin >> el; // ввод ключа удаляемой вершины
    A.Delete(A.GetTree(), el); // удаление вершины из дерева
    A.Vyvod(A.GetTree(), 0); // вывод дерева на экран

    cout << "\n";
    system("PAUSE"); // приостановка работы программы

}

void TREE::BuildTree()
//Построение бинарного дерева.
//Tree - указатель на вершину дерева.
{
    int el;//переменная для ввода эелментов

    cout << "Вводите ключи вершин дерева: \n"; // Запрос на ввод ключей вершин дерева.
    cin >> el; // Чтение первого ключа.
    while (el != 0) // Цикл продолжается, пока не будет введен 0.
    {
        Search(el, &Tree); // Добавление вершины с ключом el в дерево.
        cin >> el; // Чтение следующего ключа.
    }

}

void TREE::Vyvod(node** w, int l)
//Изображение дерева w на экране дисплея
//         (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;//счетчик для уровня дерева

    if (*w != NULL) // Если корень не пустой,
    {
        Vyvod(&((**w).Right), l + 1); // Рекурсивный вызов функции для правого поддерева.
        for (i = 1; i <= l; i++) cout << "   "; // Отступ слева для текущей вершины.
        cout << (**w).Key << endl; // Вывод ключа текущей вершины.
        Vyvod(&((**w).Left), l + 1); // Рекурсивный вызов функции для левого поддерева.
    }

}

void TREE::Search(int x, node** p)
// Поиск звена x в бинарном дереве со вставкой (рекурсивный алгоритм).
// *p - указатель на вершину дерева.
{
    if (*p == NULL) //если дерево не пустое
    {
        // Вершины в дереве нет; включить ее.
        *p = new(node); // выделение памяти под новое звено
        (**p).Key = x; // присвоение значения ключу звена
        (**p).Count = 1; // инициализация количества
        (**p).Left = (**p).Right = NULL; // инициализация указателей на левое и правое поддеревья
    }
    else
        if (x < (**p).Key)// если x меньше ключа текущего звена, переходим в левое поддерево
            Search(x, &((**p).Left));// Рекурсивный вызов для левой подветки дерева.
        else
            if (x > (**p).Key)// если x больше ключа текущего звена, переходим в правое поддерево
                Search(x, &((**p).Right));// Рекурсивный вызов для правой подветки дерева.
            else// если x равен ключу текущего звена, увеличиваем значение количества
                (**p).Count += 1;// Увеличение счетчика, если ключ уже присутствует в дереве.
}

void TREE::Addition(int k)
// Поиск звена k в бинарном дереве со вставкой (нерекурсивный алгоритм).
// Tree - указатель на вершину дерева.
{
    node* s;//рабочий указатель
    Poisk(k); // ищем звено с ключом k
    if (!B)
    { // если звено не найдено, вставляем новое
        s = new(node); // выделение памяти под новое звено
        (*s).Key = k; // присвоение значения ключу звена
        (*s).Count = 1; // инициализация количества
        (*s).Left = (*s).Right = NULL; // инициализация указателей на левое и правое поддеревья
        if (Tree == NULL) Tree = s; // если дерево пустое, новое звено становится корнем
        else
            if (k < (*Res).Key) (*Res).Left = s; // если k меньше ключа найденного звена, новое звено становится левым потомком найденного звена
            else  (*Res).Right = s; // если k больше ключа найденного звена, новое звено становится правым потомком найденного звена
    }
    else  (*Res).Count += 1; // если звено найдено, увеличиваем значение количества
}


int TREE::Poisk(int k)
// Поиск вершины с ключом k в дереве
//      (нерекурсивный алгоритм).
// Tree - указатель на бинарное дерево.
// Res  - указатель на найденную вершину
// или на лист, к которому можно присоединить новую вершину.
{
    node* p, * q;//рабочие указатели

    B = FALSE; //флаг нахождения элемента в дереве
    p = Tree;//устанавливаем указатель на начало дерева
    if (Tree != NULL) //если дерево не пустое
        q = p;
        do
        {
            q = p; //указатель на родительский узел
            if ((*p).Key == k) B = TRUE; //элемент найден
            else//элемент не найден
            {
                q = p;
                if (k < (*p).Key) p = (*p).Left; //двигаемся влево
                else  p = (*p).Right; //двигаемся вправо
            }
        } while (!B && p != NULL); //пока не найден элемент и не достигнут конец дерева
        Res = q; //указатель на последний просмотренный узел
        return B; //возвращаем флаг нахождения элемента

}

node* TREE::Poisk_1(int k, node** p)
// Поиск вершины с ключом k в дереве
// (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
    if (*p == NULL) {
        return (NULL); // Если корень пустой, вернуть NULL
    }
    else if ((**p).Key == k) {// Если найден ключ k
        return (*p); //вернуть указатель на эту вершину
    }
    else if (k < (**p).Key) {// если k меньше ключа текущего звена
        return Poisk_1(k, &((**p).Left)); // Рекурсивный поиск в левом поддереве
    }
    else {// если k больше ключа текущего звена
        return Poisk_1(k, &((**p).Right)); // Рекурсивный поиск в правом поддереве
    }
}

void TREE::Delete(node** p, int k)
// Удаление вершины k из бинарного дерева.
// *p - указатель на корень дерева.
{
    node* q;//объявление рабочего указателя

    if (*p == NULL) {//если дерево пустое
        cout << "Вершина с заданным ключом не найдена!\n"; // Вершина с заданным ключом не найдена
    }
    else if (k < (**p).Key) {// если k меньше ключа текущего звена
        Delete(&((**p).Left), k); // Рекурсивный вызов для левого поддерева
    }
    else if (k > (**p).Key) {// если k больше ключа текущего звена
        Delete(&((**p).Right), k); // Рекурсивный вызов для правого поддерева
    }
    else {// Если вершина с ключом k найдена, то выполняется удаление этой вершины
        q = *p;
        if ((*q).Right == NULL) {// Если у вершины q нет правого поддерева, то её левое поддерево становится на место q
            *p = (*q).Left;//левое поддерево становится на место q
            delete q; // Удаление вершины q, которая не имеет правого поддерева
        }
        else if ((*q).Left == NULL) {// Если у вершины q нет левого поддерева, то её правое поддерево становится на место q
            *p = (*q).Right;//правое поддерево становится на место q
            delete q; // Удаление вершины q, которая не имеет левого поддерева
        }
        else {// Если у вершины q есть и левое, и правое поддеревья, то удаляем у неё максимальный элемент в левом поддереве
            Delete_1(&((*q).Left), &q); // Удаление вершины q, которая имеет и левое, и правое поддеревья
        }
    }
}


void TREE::Delete_1(node** r, node** q)
{
    node* s;//объявление рабочего указателя

    if ((**r).Right == NULL) // Если правое поддерево *r пусто
    {
        (**q).Key = (**r).Key; (**q).Count = (**r).Count; // Копируем ключ и счётчик из *r в *q
        *q = *r; // Переносим ссылку на *r в *q
        s = *r; *r = (**r).Left; delete s; // Удаляем *r и делаем (*r)-левое поддерево единственным поддеревом **q.
    }
    else  Delete_1(&((**r).Right), q); // Иначе выполняем удаление в правом поддереве **r
}
