//Постpоение деpева отpезков и вывод его на экpан дисплея.

#include <iostream> // подключение библиотеки ввода/вывода
using namespace std; // объявление пространства имен std

struct node // Определение структуры node, которая представляет вершину дерева отрезков.
{
    int KeyMin; // Минимальный ключ вершины.
    int KeyMax; // Максимальный ключ вершины.
    node* Left; // Указатель на "левого" сына.
    node* Right; // Указатель на "правого" сына.
};

class TREE // Определение класса TREE, который представляет дерево отрезков.
{
private:
    node* Tree; // Указатель на корень дерева.
    void Search(int, int, node**); // Определение приватной функции Search, которая рекурсивно ищет место для вставки новой вершины в дерево.
public:
    TREE() { Tree = NULL; } // Определение конструктора класса TREE, который инициализирует указатель на корень дерева значением NULL.
    void BuildTree(); // Определение публичной функции BuildTree, которая строит дерево отрезков.
    node** GetTree() { return &Tree; } // Определение публичной функции GetTree, которая возвращает указатель на корень дерева.
    void CleanTree(node**);// Определение публичной функции CleanTree, которая рекурсивно удаляет все вершины дерева.
    void Vyvod(node**, int);// Определение публичной функции Vyvod, которая рекурсивно выводит все вершины дерева на экран.
};

void main()
{
    setlocale(LC_ALL, "Rus"); // Установка русской локали для вывода сообщений на кириллице.
    TREE A; // Создание объекта класса TREE.

    A.BuildTree(); // Вызов функции BuildTree() для построения дерева отрезков.
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0); // Вызов функции Vyvod() для вывода дерева на экран.
    A.CleanTree(A.GetTree()); // Вызов функции CleanTree() для удаления дерева из памяти.

    cout << "\n";
    system("PAUSE"); // Приостановка выполнения программы, ожидание нажатия любой клавиши пользователем.

}

void TREE::BuildTree()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
    int k1, k2;
    cout << "Введите два целых числа...\n"; // Просим пользователя ввести два целых числа.
    cin >> k1; // Читаем первое число из консоли.
    cin >> k2; // Читаем второе число из консоли.
    Search(k1, k2, &Tree); // Вызываем функцию Search() для поиска места в дереве, куда нужно добавить новый узел.
}

void TREE::Search(int k1, int k2, node** p) // Функция Search - рекурсивно строит дерево отрезков с корнем в вершине, на которую указывает p.
{
    if (k2 - k1 > 1)// Если длина отрезка больше 1, то создаем новую вершину дерева.
    {
        *p = new (node); // Выделяем память под новую вершину.
        (**p).KeyMin = k1; // Устанавливаем минимальное значение ключа вершины.
        (**p).KeyMax = k2; // Устанавливаем максимальное значение ключа вершины.
        (**p).Left = (**p).Right = NULL; // Инициализируем указатели на левого и правого потомков нулями.
        Search(k1, (k1 + k2) / 2, &((**p).Left));// Рекурсивно вызываем функцию Search для левого и правого потомков.
        Search((k1 + k2) / 2, k2, &((**p).Right));
    }
    else // Иначе создаем листовую вершину.
    {
        *p = new (node); // Выделяем память под новую вершину.
        (**p).KeyMin = k1; // Устанавливаем минимальное значение ключа вершины.
        (**p).KeyMax = k2; // Устанавливаем максимальное значение ключа вершины.
        (**p).Left = (**p).Right = NULL; // Инициализируем указатели на левого и правого потомков нулями.
    }
}

void TREE::CleanTree(node** w)// Функция CleanTree - рекурсивно удаляет все вершины дерева, начиная с корня, на который указывает w.
{
    if (*w != NULL) // Если указатель не равен нулю, то есть вершина существует.
    {
        CleanTree(&((**w).Left));// Рекурсивно вызываем функцию CleanTree для левого и правого потомков.
        CleanTree(&((**w).Right));
        delete w; // Удаляем вершину.
    }
}

// Функция рекурсивно выводит на экран содержимое дерева отрезков.
// w - указатель на текущую вершину дерева, которую нужно вывести.
// l - текущий уровень вложенности вершины в дерево (для корректного форматирования вывода).
void TREE::Vyvod(node** w, int l)
{
    int i; //счетчик для уровня дерева
    if (*w != NULL) // Проверяем, не является ли текущая вершина пустой.
    {
        Vyvod(&((**w).Right), l + 1);// Рекурсивно выводим правое поддерево.

        for (i = 1; i <= l; i++) cout << "   ";// Отступаем на текущий уровень и выводим ключи вершины.
        cout << (**w).KeyMin << ", " << (**w).KeyMax << endl;//выводим значение ключа на экран

        // Рекурсивно выводим левое поддерево.
        Vyvod(&((**w).Left), l + 1);
    }
}
