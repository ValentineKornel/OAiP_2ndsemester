#include<iostream>
using namespace std;

struct node
{
    int  elem;   //элемент списка
    node* sled;   //указатель на следующий элемент списка
};
class Spisok {
private:
    node* phead, * Res;  //указатель на заглавное звено и рабочий указатель Res для операций поиска и удаления.
public:
    Spisok() { phead = new(node); Res = NULL; } // конструктор класса, создающий заглавное звено и инициализирующий рабочий указатель
    ~Spisok() { delete phead; } // деструктор класса, удаляющий заглавное звено
    void POSTROENIE(); // метод построения списка
    void VYVOD(); // метод вывода содержимого списка
    node* POISK(int);  // метод поиска звена с заданным элементом
    void YDALE(); // метод удаления звена, расположенного после заданного элемента
    void YDALE1(); // метод удаления звена с заданным элементом
    void OCHISTKA();  // метод очистки памяти, выделенной под список
};

void main()
/*В функции `main()` создается объект класса `Spisok`, вызываются его методы для работы со списком, а затем происходит очистка памяти.*/
{
    setlocale(LC_ALL, "Rus");
    Spisok A; // создание объекта класса Spisok
    int   el; //переменная для ввода элементов списка
    node* Res_Zn;  //указатель на найденный элемент списка

    A.POSTROENIE(); //вызов метода построения списка
    A.VYVOD(); //вызов метода вывода списка на экран
    cout << "\nВведите элемент звена, после которого ";
    cout << "осуществляется удаление:\n";
    cin >> el; //ввод элемента звена
    Res_Zn = A.POISK(el);  //поиск звена с заданным элементом в списке
    if (Res_Zn != NULL && (*Res_Zn).sled != NULL)
    {
        A.YDALE(); A.VYVOD(); //удаление звена и вывод списка на экран
    }
    else  cout << "Звена с заданным элементом в списке нет!";
    cout << "\nВведите удаляемый элемент звена:\n";
    cin >> el;
    Res_Zn = A.POISK(el);
    if (A.POISK(el) != NULL)
    {
        A.YDALE1(); A.VYVOD(); cout << endl;
    }
    else  cout << "Звена с заданным элементом в списке нет!";
    A.OCHISTKA();

    cout << "\n";
    system("PAUSE");
}

void Spisok::POSTROENIE()
/*Метод `POSTROENIE()` позволяет построить однонаправленный список, начиная с заглавного звена. 
При этом происходит динамическое выделение памяти под новые элементы списка. */
//phead -указатель на заглавное звено
{
    node* t; // рабочий указатель для создания новых звеньев
    int  el; // переменная для ввода элементов списка

    t = phead; (*t).sled = NULL; // указатель указывает на начало списка, заглавное звено не содержит элементов
    cout << "Вводите элементы звеньев списка: ";
    cin >> el;  // вводим первый элемент списка
    while (el != 0)  // пока не введен 0
    {
        (*t).sled = new (node);  // выделяем память под новый элемент списка
        t = (*t).sled; (*t).elem = el; (*t).sled = NULL;  // инициализируем новое звено и перемещаем указатель на него
        cin >> el;  // вводим следующий элемент списка
    }
}


void Spisok::VYVOD()
/*Метод `VYVOD()` выводит содержимое списка, начиная с первого элемента. Перемещение по списку осуществляется 
с помощью указателя на текущий элемент (`t`), который изменяется на указатель на следующий элемент 
при переходе к следующему звену.*/
//phead - указатель на заглавное звено.
{
    node* t;  //рабочий указатель на текущий элемент списка

    t = phead; t = (*t).sled;  //устанавливаем указатель на первый элемент списка, ереходим на первый элемент списка
    cout << "Список: ";
    while (t != NULL)  //цикл перебора всех элементов списка
    {
        cout << (*t).elem << " ";  //выводим значение текущего элемента
        t = (*t).sled; //переходим к следующему элементу
    }
}

node* Spisok::POISK(int el)
/*Метод `POISK()` осуществляет поиск звена с заданным элементом в списке, начиная с первого элемента. 
Перемещение по списку осуществляется с помощью указателя на текущий элемент (`t`), который изменяется 
на указатель на следующий элемент при переходе к следующему звену. Если звено с заданным элементом найдено, 
его адрес сохраняется в переменной `Res`, иначе `Res` остается равным `NULL`.*/
//списка. В противном случае Res содержит NULL.
{
    node* t; //рабочий указатель на текущий элемент списка

    Res = NULL; t = phead; t = (*t).sled; //обнуляем указатель на найденный элемент, //устанавливаем указатель на первый элемент списка, //переходим на первый элемент списка
    while (t != NULL && Res == NULL) //цикл перебора всех элементов списка до нахождения нужного элемента или конца списка
        if ((*t).elem == el)  Res = t; //если элемент найден, сохраняем его адрес в Res
        else  t = (*t).sled;  //переходим к следующему элементу
    return Res; //возвращаем указатель на найденный элемент списка
}

void Spisok::YDALE()
/*Метод `YDALE()` удаляет звено, следующее за заданным элементом в списке. 
Если звено не является последним, указатель на следующий элемент списка перенаправляется 
на элемент, следующий за удаляемым, а затем удаляется удаляемый элемент. Если звено является 
последним, выводится сообщение об ошибке.*/

{
    node* q; //рабочий указатель на текущий элемент списка
    q = (*Res).sled; //указатель на следующий элемент после удаляемого звена
    if (q != NULL)
    {
        //Если звено, после которого нужно удалять,
        //не является последним, то:
        (*Res).sled = (*(*Res).sled).sled; delete q;
    }
    else
        cout << "Звено с заданным элементом - последнее!\n";
}

void Spisok::YDALE1()
/*Метод `YDALE1()` удаляет звено с заданным элементом из списка. Если звено существует, его элемент копируется 
в заданное звено, указатель на следующий элемент списка перенаправляется на следующий элемент после удаляемого 
звена, а затем удаляется удаляемое звено. Если звено не существует, указатель на предыдущий элемент списка 
перенаправляется на `NULL`, удаляемое звено удаляется, а указатель на следующее звено после удаленного звена 
устанавливается в `NULL`.*/
{
    node* q, * q1, * q2;

    q = (*Res).sled; //указатель на следующий элемент после удаляемого звена
    if (q != NULL) //если следующий элемент существует
    {
        (*Res).elem = (*q).elem; (*Res).sled = (*q).sled; //копируем элемент из следующего звена в заданное звено, перенаправляем указатель на следующий элемент списка, 
        delete q; //удаляем следующее звено
    }
    else //если следующего элемента нет (удаляемый элемент последний в списке)
    {
        q1 = phead; q2 = (*q1).sled; //устанавливаем указатель на заглавное звено, //устанавливаем указатель на первый элемент списк
        while (q2 != Res) //ищем предыдущий элемент перед удаляемым звеном
        {
            q1 = q2; q2 = (*q2).sled;
        }
        (*q1).sled = NULL; q2 = NULL; delete Res; //перенаправляем указатель на предыдущий элемент списка на NULL, устанавливаем указатель на следующее звено после удаленного звена в NULL, удаляем удаляемое звено
    }
}

void Spisok::OCHISTKA()
/*Метод `OCHISTKA()` очищает память, выделенную под список. Перемещение по списку осуществляется с помощью указателей 
на текущий и следующий элементы списка (`q` и `q1`). При удалении текущего звена указатель `q` перемещается на следующий 
элемент списка, а `q1` перемещается на следующее за ним звено.*/
// phead - указатель на заглавное звено списка.
{
    node* q, * q1;// Рабочие указатели.

    q = phead;
    q1 = (*q).sled; // Указатель q1 "опережает" указатель q.
    while (q1 != NULL)  //цикл перебора всех элементов списка
    {
        q = q1; q1 = (*q1).sled; delete q;
    }
}
