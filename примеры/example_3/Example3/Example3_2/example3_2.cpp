#include<iostream>
using namespace std;

struct node // Описаниe структуры узла связанного списка
{
    int elem; // информационное поле узла
    node* sled; // указатель на следующий узел
};

class Spisok // Описание класса Список
{
private:
    node* stk; // указатель на вершину стека
    int klad; // переменная, хранящая значение удаленного элемента
public:
    Spisok() { stk = NULL; } // конструктор класса, инициализирует указатель на NULL
    int Set_Stack() { return klad; } // метод класса, возвращает значение переменной klad
    void POSTROENIE(); // метод класса, выполняющий построение списка
    void VYVOD(); // метод класса, выводящий на экран содержимое списка
    void W_S(int); // метод класса, добавляющий элемент в стек
    void YDALENIE(); // метод класса, удаляющий элемент из стека
    void OCHISTKA(); // метод класса, освобождающий выделенную память для списка
    bool contains(int el); //метод класса, проверяющий есть ли заданный элемент в стеке
    int GETFIRST();  // метод класса, возвращающий верхний элемент стека
    bool ISEMPTY();  // метод класса, проверяющий содержит ли стек элементы
    void ADDBEFORE(int value, int after); // метод класса, добавляющий элемент в стек перед заданным числом
    void ADDAFTER(int value, int after); // метод класса, добавляющий элемент в стек после заданного числа
    void ADD_ELM_VMESTO(int old_el, int new_el); //метод класса, добавляющий элемент в стек вместо заданного числа
};


void main() // Определение главной функции программы
{
    setlocale(LC_ALL, "Rus"); // установка локали для отображения русского текста в консоли
    Spisok A; // создание объекта класса Список
    int el; // переменная для ввода элемента в стек
    int t; // переменная для хранения значения удаленного элемента с верхушки стека

    A.POSTROENIE(); // вызов метода POSTROENIE() для построения списка
    A.VYVOD(); // вывод на экран содержимого списка
    cout << "Введите вставляемый элемент: ";
    cin >> el; // Ввод элемета с клавиатуры
    A.W_S(el); // добавление элемента в стек
    A.VYVOD(); // вывод на экран содержимого списка
    cout << "Верхним элементом стека является число " << A.GETFIRST() << endl;

    cout << "Удалим элемент из стека.\n";
    A.YDALENIE(); // удаление элемента из стека
    t = A.Set_Stack(); // получение значения удаленного элемента
    cout << "Из стека было извлечено число... " << t << endl;
    A.VYVOD(); // вывод на экран содержимого списка

    cout << "Введите число, перед которым хотите вставить элемент: ";
    int el1;
    cin >> el1;
    cout << "Введите число, которое хотите вставить: ";
    cin >> el;
    A.ADDBEFORE(el, el1);
    A.VYVOD();

    cout << "Введите число после которого хотите вставить элемент: ";
    cin >> el1;
    cout << "Введите число, которое хотите вставить: ";
    cin >> el;
    A.ADDAFTER(el, el1);
    A.VYVOD();

    cout << "Введите число вместо которого хотите вставить элемент: ";
    cin >> el1;
    cout << "Введите число, которое хотите вставить: ";
    cin >> el;
    A.ADD_ELM_VMESTO(el1, el);
    A.VYVOD();

    cout << "Введите элемент для проверки на существование в стеке: ";
    cin >> el;
    if (A.contains(el))
        cout << "Элемент есть в стеке" << endl;
    else
        cout << "Данного элемента нет в стеке";


    A.OCHISTKA(); // освобождение выделенной памяти для списка


    cout << "\n";
    system("PAUSE"); // приостановка работы программы до нажатия любой клавиши
}

void Spisok::POSTROENIE()
//Построение стека, заданного указателем stk.
{
    node* t; // Создание указателя на структуру node
    int el; // Создание переменной el для хранения элементов стеки, вводимых пользователем

    cout << "Вводите элементы стека: ";
    cin >> el;  // Ввод элемета с клавиатуры
    while (el != 0)  // пока не введен 0
    {
        t = new (node); // выделение памяти под новый элемент стека
        (*t).elem = el; (*t).sled = stk; // инициализация нового элемента стека
        stk = t; // указатель на новый элемент стека становится вершиной стека
        cin >> el; // Ввод элемета с клавиатуры
    }
}

void Spisok::VYVOD() // Вывод содержимого стека, заданного указателем stk.
{
    node* t; // создаем указатель на узел

    cout << "Содержимое стека: ";
    t = stk; // присваиваем указателю на узел адрес верхушки стека
    while (t != NULL) // пока указатель не равен нулю
    {
        cout << (*t).elem << " "; // выводим значение элемента стека
        t = (*t).sled; // переходим к следующему элементу стека
    }
    cout << endl; // выводим символ новой строки
}

void Spisok::W_S(int el)
//Помещение элемента el в стек stk.
{
    node* q; // Создаем указатель на узел списка

    q = new (node);  // Выделяем память под новый узел списка
    (*q).elem = el; // Присваиваем значение элемента в информационное поле нового узла
    (*q).sled = stk; // Присваиваем указателю на следующий элемент в списке значение текущего верхнего элемента стека
    stk = q;  // Обновляем указатель на верхний элемент стека на новый элемент
}

void Spisok::YDALENIE()
//Удаление элемента из стека, заданного указателем stk.
//Значение информационного поля удаляемого элемента
//помещается в параметр klad.
{
    node* q; // Создаем указатель на узел списка
    
    if (stk == NULL)  // проверяем, что стек не пуст
        cout << "Стек пуст!\n";
    else
    {
        klad = (*stk).elem; q = stk; // сохраняем значение информационного поля верхнего элемента
        stk = (*stk).sled; delete q; // удаляем верхний элемент
    }
}

void Spisok::OCHISTKA()
//Возврат выделенной памяти в "кучу".
{
    node* t, * q;

    t = stk;
    if (t != NULL) // проверяем, что стек не пустой
    {
        q = (*t).sled; // устанавливаем указатель q на следующий элемент стека
        while (q != NULL) // пока не достигнут конец стека
        {
            delete t; // удаляем текущий элемент
            t = q; // устанавливаем указатель t на следующий элемент
            q = (*q).sled; // устанавливаем указатель q на следующий элемент стека
        }
        delete t; // удаляем последний элемент
    }
}

bool Spisok::contains(int el) { // Поиск элемента в стеке, заданном указателем stk.
    // Функция возвращает true, если элемент el присутствует в стеке, и false, если отсутствует.
    node* t = stk;   // начинаем поиск с вершины стека
    while (t != NULL) { // пока не достигнут конец стека
        if ((*t).elem == el) { // если текущий элемент равен искомому
            return true; // возвращаем true
        }
        t = (*t).sled; // переходим к следующему элементу
    }
    return false; // если элемент не найден, возвращаем false
}

bool Spisok::ISEMPTY() {
    if (stk == NULL) {
        return false; // стек пуст
    }
    else {
        return true; // стек содержит элементы
    }
}

int Spisok::GETFIRST()
{
    if (stk == NULL) // если стек пустой
    {
        cout << "Стек пустой!\n";
        return 0;
    }
    else // если стек не пустой
    {
        return (*stk).elem; //возвращаем верхний элемент стека
    }
}

void Spisok::ADDBEFORE(int value, int before) {
    if (stk == NULL) {  // Если стек пуст, выводим сообщение об ошибке и прерываем функцию
        cout << "Ошибка: стек пуст!" << endl;
        return;
    }

    node* t = stk;  // устанавливаем указатель на начало стека
    while (t != NULL) { // Проходим по элементам стека
        if ((*t).elem == before) { // Если найден элемент со значением after, добавляем новый элемент перед ним и прерываем функцию
            node* new_node = new node; // Создаем новый узел
            (*new_node).elem = value; // Устанавливаем значение нового узла
            (*new_node).sled = (*t).sled; // Устанавливаем связь нового узла со следующим элементом
            (*t).sled = new_node; // Устанавливаем связь текущего элемента со вставленным элементом
            return;
        }
        t = (*t).sled; // переходим к следующему элементу
    }
    cout << "Ошибка: элемент " << before << " не найден в стеке!" << endl;  // Если элемент не найден, выводим сообщение об ошибке
}

void Spisok::ADDAFTER(int value, int after) {
    node* t = stk;  // устанавливаем указатель на начало стека
    node* prev = NULL;  // Устанавливаем указатель на предыдущий элемент
    while (t != NULL) {  // Перебираем элементы стека
        if ((*t).elem == after) {  // Если нашли элемент, после которого нужно вставить новый элемент
            node* newNode = new node;  // Создаем новый элемент и заполняем его значениями
            (*newNode).elem = value;
            (*newNode).sled = t;
            if (prev == NULL) { // Если предыдущий элемент не задан, значит, вставляем новый элемент перед первым элементом
                stk = newNode;
            }
            else { // Иначе вставляем новый элемент между двумя существующими элементами
                (*prev).sled = newNode;
            }
            return; // Завершаем функцию после добавления элемента
        }
        prev = t; // Перемещаем указатель на предыдущий элемент
        t = (*t).sled; // Перемещаем указатель на следующий элемент
    }
    // Если элемент не найден, выводим сообщение об ошибке
    cout << "Ошибка: элемент " << after << " не найден в стеке" << endl;
}

void Spisok::ADD_ELM_VMESTO(int old_el, int new_el) {
    node* t = stk;       // устанавливаем указатель на начало списка
    node* prev = NULL;   // устанавливаем указатель на предыдущий элемент
    node* to_del = NULL; // устанавливаем указатель на элемент, который необходимо удалить

    while (t != NULL) {  // проходим по всему списку, пока не достигнем конца
        if (t->sled->elem == old_el) // проверяем, является ли следующий элемент текущего элемента искомым элементом
            prev = t; // если да, то сохраняем указатель на предыдущий элемент
        if ((*t).elem == old_el) { // если текущий элемент - искомый элемент
            node* new_node = new node; // создаем новый элемент
            (*prev).sled = new_node;   // предыдущий элемент теперь должен указывать на новый элемент
            (*new_node).elem = new_el; // присваиваем новому элементу значение new_el
            (*new_node).sled = (*t).sled; // новый элемент теперь должен указывать на элемент, который шел после old_el
            delete t;  // удаляем элемент, который содержал значение old_el
            return;
        }
        t = (*t).sled; // переходим к следующему элементу списка
    }
    cout << "Элемент " << old_el << " не найден в стеке" << endl; // если искомый элемент не найден, выводим сообщение об ошибке
}