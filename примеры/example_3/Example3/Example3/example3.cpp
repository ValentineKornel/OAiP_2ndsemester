#include<iostream> // Подключение библиотеки для ввода-вывода на консоль
using namespace std; // Использование стандартного пространства имен


struct node // Определение структуры узла списка
{
    int elem; // Целочисленное значение, хранимое в узле
    node* sled; // Указатель на следующий узел в списке
};


class Spisok { // Определение класса списка
private:
    node* no, * ko; // Указатели на начало и конец списка соответственно
    int klad; // Поле для хранения удаленного элемента
public:
    Spisok() { no = ko = NULL; } // Конструктор, устанавливающий начальные значения полей
    void POSTROENIE(); // Метод для построения списка
    void VYVOD(); // Метод для вывода списка на консоль
    void DOBAVLENIE(int); // Метод для добавления элемента в конец списка
    int Set_Udal() { return klad; }// Метод для получения удаленного элемента
    void YDALENIE(); // Метод для удаления элемента из начала списка
    void OCHISTKA(); // Метод для освобождения памяти, занятой списком
    void PRIORITY_VKL(int el);
};


void main() // Определение главной функции программы
{
    setlocale(LC_ALL, "Rus"); // Установка локали для корректного отображения русских символов на консоли
    Spisok A;  // Создание объекта списка
    int el;    // Целочисленная переменная для ввода элементов

    A.POSTROENIE();           // Вызов метода для построения списка
    A.VYVOD();                // Вызов метода для вывода списка на консоль
    cout << "Введите добавляемый элемент: ";
    cin >> el;                // Ввод элемета с клавиатуры
    A.DOBAVLENIE(el); A.VYVOD(); // Добавление элемента в конец списка и вывод списка на консоль
    cout << "Удалим элемент из очереди.\n";
    A.YDALENIE(); A.VYVOD();     // Удаление элемента из начала списка и вывод списка на консоль
    el = A.Set_Udal();           // Получение удаленного элемента
    cout << "Информационное поле удаленного звена: " << el << endl;
    cout << "Введите элемент для приоритетной вставки: ";
    cin >> el;  // Ввод элемета с клавиатуры
    A.PRIORITY_VKL(el);          //Вызов метода для приоритетного включения эемента в список
    A.VYVOD();                   // Вызов метода для вывода списка на консоль
    A.OCHISTKA();                // Освобождение памяти, занятой списком
    cout << endl;

    cout << "\n";
    system("PAUSE");             // Приостановка работы программы до нажатия пользователем любой клавиши
}

void Spisok::POSTROENIE()
//Построение очереди на базе однонаправленного списка
//без заглавного звена.
//no - указатель на начало очереди.
//ko - указатель на конец очереди.
{
    node* r; // Создание указателя на структуру node
    int el; // Создание переменной el для хранения элементов очереди, вводимых пользователем

    cout << "Вводите элементы очереди:\n";
    cin >> el; // Чтение первого элемента очереди
    if (el != 0)
    {
        r = new (node); // Выделение памяти для нового элемента и присвоение указателю r его адреса
        (*r).elem = el; // Присвоение новому элементу значения el
        (*r).sled = NULL; // Установка указателя на следующий элемент в NULL
        no = r; // Установка указателя no на начало очереди (на созданный новый элемент)
        ko = r; // Установка указателя ko на конец очереди (также на созданный новый элемент)
        cin >> el; // Чтение следующего элемента очереди
        while (el != 0)
        {
            r = new (node); // Выделение памяти для нового элемента и присвоение указателю r его адреса
            (*r).elem = el; // Присвоение новому элементу значения el
            (*r).sled = NULL; // Установка указателя на следующий элемент в NULL
            (*ko).sled = r; // Установка указателя на следующий элемент для последнего элемента в списке (ко)
            ko = r; // Установка указателя ko на последний элемент в списке
            cin >> el; // Чтение следующего элемента очереди
        }
    }
    else
    {
        r = NULL; // Если в очереди нет элементов, то указатель r устанавливается в NULL
        no = r; // Установка указателя no на начало очереди (NULL)
        ko = r; // Установка указателя ko на конец очереди (NULL)
    }

}

void Spisok::VYVOD()
//Вывод содержимого очереди.
//no - указатель на начало очереди.
//ko - указатель на конец очереди.
{
    node* r; // Создание указателя на структуру node
    cout << "Очередь: "; r = no; // начало очереди устанавливается в r
    while (r != NULL) // пока не достигнут конец очереди
    {
        cout << (*r).elem << " "; // выводится значение элемента
        r = (*r).sled; // переход к следующему элементу
    }
    cout << endl;  // переход на новую строку
}

void Spisok::DOBAVLENIE(int el)
//Добавление звена с информационным полем el к очереди,
//определенной указателями  no и ko.
{
    node* r; // Создание указателя на структуру node

    r = new (node); //Выделение памяти под новый узел
    (*r).elem = el; (*r).sled = NULL; //Инициализация полей нового узла
    if (no != NULL) //Если очередь не пуста
    {
        (*ko).sled = r; //Указатель на следующий узел последнего элемента указывает на новый узел
        ko = r; //Указатель на последний элемент теперь указывает на новый узел
    }
    else //Если очередь пуста
    {
        no = r; //Указатель на первый элемент теперь указывает на новый узел
        ko = r; //Указатель на последний элемент теперь указывает на новый узел
    }
}

void Spisok::YDALENIE()
//Удаление звена из очереди, определенной указателями
//no и ko, с помещением его информационного поля в
//параметр klad.
{
    node* q; // Объявление указателя на структуру node

    if (no == NULL) // Проверяем, не является ли очередь пустой
        cout << "Удалить нельзя, так как очередь пуста!\n";
    else
    {
        klad = (*no).elem; // Записываем значение информационного поля первого звена в параметр klad
        q = no; // Запоминаем указатель на первое звено
        no = (*no).sled; // Сдвигаем указатель на начало очереди на следующее звено
        delete q; // Освобождаем память, занимаемую удаленным звеном
    }
}

void Spisok::OCHISTKA()
//Возврат выделенной памяти в "кучу".
{
    node* q;
    q = no;// Объявление указателя на первый элемент очереди

    if (no != NULL) // Если очередь пуста, то нет необходимости освобождать выделенную память
    {
        while (no != ko) // Проходимся по всем элементам очереди, начиная с первого
        {
            no = (*q).sled; // Запоминаем указатель на текущий элемент
            delete q; // Удаляем элемент
            q = no; // Перемещаем указатель на следующий элемент
        }
        delete no; // Удаляем последний элемент
        no = ko = NULL; // Обнуляем указатели на первый и последний элементы очереди
    }
}

void Spisok::PRIORITY_VKL(int el)
{
    node* p = no;       // Указатели на текущий элемент, предыдущий элемент и новый элемент
    node* q = nullptr;
    node* r = new node;
    r->elem = el;    // Инициализация нового элемента
    r->sled = nullptr;

    if (no == nullptr) {  // Если очередь пуста, добавляем первый элемент
        no = r;
        ko = r;
    }
    else {  // Ищем элемент с меньшим приоритетом
        while (p != nullptr && p->elem < el) {
            q = p;
            p = p->sled;
        }

        // Вставляем элемент в нужное место
        if (p == no) { // Вставка в начало очереди
            r->sled = no;
            no = r;
        }
        else if (p == nullptr) { // Вставка в конец очереди
            ko->sled = r;
            ko = r;
        }
        else { // Вставка в середину очереди
            r->sled = p;
            q->sled = r;
        }
    }
}